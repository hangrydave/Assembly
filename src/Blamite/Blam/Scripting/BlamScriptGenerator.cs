#if NET45

using Blamite.IO;
using System;
using System.CodeDom.Compiler;
using System.Globalization;
using System.Text;
using System.Diagnostics;
using Blamite.Serialization;
using System.IO;

namespace Blamite.Blam.Scripting
{
	// This code sucks...
	public class BlamScriptGenerator
	{
		private readonly OpcodeLookup _opcodes;
		private readonly ScriptTable _scripts;
		private readonly Endian _endian;
		private readonly EngineDescription _buildInfo;
		private bool _nextFunctionIsScript;
		private bool _onNewLine = true;
		private bool _h4;

		private bool _nextExpressionIsVar;
		private bool _varTypeWritten;
		private int localVarCounter;

		public BlamScriptGenerator(ScriptTable scripts, OpcodeLookup opcodes, EngineDescription buildInfo, Endian endian)
		{
			_endian = endian;
			_scripts = scripts;
			_opcodes = opcodes;
			_buildInfo = buildInfo;
		}

		public string Decompile(string sourceFile, bool showInfo)
        {
			IndentedTextWriter output = new IndentedTextWriter(new StringWriter(CultureInfo.InvariantCulture));
			DateTime startTime = DateTime.Now;
			Stopwatch watch = Stopwatch.StartNew();
			output.WriteLine();

			if(GenerateVariables(output, showInfo))
            {
				output.WriteLine();
				output.WriteLine();
			}

			if(GenerateGlobals(output, showInfo))
            {
				output.WriteLine();
				output.WriteLine();
			}

			GenerateScripts(output, showInfo);

			watch.Stop();
			return GenerateHeader(sourceFile, startTime, watch.Elapsed) + output.InnerWriter.ToString();
		}

		private bool GenerateVariables(IndentedTextWriter output, bool showInfo)
		{
			if (_scripts.Variables is null || _scripts.Variables.Count == 0)
			{
				return false;
			}

			WriteComment("VARIABLES", output);
			output.WriteLine();

			for (int counter = 0; counter < _scripts.Variables.Count; counter++)
			{
				ScriptGlobal variable = _scripts.Variables[counter];
				output.Write("(variable {0} {1} ", _opcodes.GetTypeInfo((ushort)variable.Type).Name, variable.Name);
				WriteExpression(variable.ExpressionIndex, output);
				if (showInfo)
                {
					output.WriteLine(")\t\t; Index: {0}, Expression Index: {1}", counter.ToString(), variable.ExpressionIndex.Index.ToString());
				}
				else
                {
					output.WriteLine(")");
				}
			}

			return true;
		}

		private bool GenerateGlobals(IndentedTextWriter output, bool showInfo)
        {
			if (_scripts.Globals is null || _scripts.Globals.Count == 0)
			{
				return false;
			}

			WriteComment("GLOBALS", output);
			output.WriteLine();

			for (int counter = 0; counter < _scripts.Globals.Count; counter++)
			{
				ScriptGlobal global = _scripts.Globals[counter];
				output.Write("(global {0} {1} ", _opcodes.GetTypeInfo((ushort)global.Type).Name, global.Name);
				WriteExpression(global.ExpressionIndex, output);
				if (showInfo)
                {
					output.WriteLine(")\t\t; Index: {0}, Expression Index: {1}", counter.ToString(), global.ExpressionIndex.Index.ToString());
				}
				else
                {
					output.WriteLine(")");
				}
			}

			return true;
		}

		private bool GenerateScripts(IndentedTextWriter output, bool showInfo)
        {
			if (_scripts.Scripts is null || _scripts.Scripts.Count == 0)
			{
				return false;
			}

			WriteComment("SCRIPTS", output);
			output.WriteLine();

			for (int counter = 0; counter < _scripts.Scripts.Count; counter++)
			{
				var script = _scripts.Scripts[counter];

				// filter out branch scripts which were generated by the compiler
				var split = script.Name.Split(new string[] { "_to_" }, StringSplitOptions.RemoveEmptyEntries);
				if (split.Length > 1 && _scripts.Scripts.Exists(s => s.Name == split[0]))
				{
					continue;
				}

				if (showInfo)
				{
					WriteComment(string.Format("Index: {0}, Expression Index: {1}", counter.ToString(), script.RootExpressionIndex.Index.ToString()), output);
				}

				output.Write("(script {0} {1} {2}", _opcodes.GetScriptTypeName((ushort)script.ExecutionType),
					_opcodes.GetTypeInfo((ushort)script.ReturnType).Name, script.Name);

				if (script.Parameters.Count > 0)
				{
					output.Write(" (");

					bool firstParam = true;
					foreach (ScriptParameter param in script.Parameters)
					{
						if (!firstParam)
							output.Write(", ");
						output.Write("{1} {0}", param.Name, _opcodes.GetTypeInfo(param.Type).Name);
						firstParam = false;
					}

					output.Write(")");
				}

				output.Indent++;
				output.WriteLine();
				WriteExpression(script.RootExpressionIndex, output, _buildInfo.HeaderSize == 0x1E000);
				output.Indent--;

				output.WriteLine();
				output.WriteLine(")");
				output.WriteLine();

				output.Indent = 0;
			}

			return true;
		}

		private string GenerateHeader(string sourceFile, DateTime startTime, TimeSpan duration)
		{
			StringBuilder sb = new StringBuilder();
			sb.AppendLine("; Decompiled with Blamite");
			sb.AppendLine("; Source file: " + sourceFile);
			sb.AppendLine("; Start time: " + startTime);
			sb.AppendLine("; Decompilation finished in ~" + duration.TotalSeconds + "s");
			sb.AppendLine("; Remember that all script code is property of Bungie/343 Industries.");
			sb.AppendLine("; You have no rights. Play nice.\n");
			return sb.ToString();
		}

		private void WriteComment(string comment, IndentedTextWriter output)
		{
			output.WriteLine("; {0}", comment);
		}

		private void WriteExpression(ScriptExpression expression, IndentedTextWriter output)
		{
			_onNewLine = true;
			localVarCounter = 0;
			GenerateCode(expression, output, true);
		}

		public void WriteExpression(DatumIndex expressionIndex, IndentedTextWriter output, bool h4 = false)
		{
			_h4 = h4;
			WriteExpression(_scripts.Expressions.FindExpression(expressionIndex), output);
		}

		private void GenerateCode(ScriptExpression expression, IndentedTextWriter output, bool firstrun = false)
		{
			int firstIndentedArg = int.MaxValue;
			bool isFunctionCall = false;

			if (expression.Type == ScriptExpressionType.Expression || expression.Type == ScriptExpressionType.Expression4)
			{
				ScriptValueType type = _opcodes.GetTypeInfo((ushort)expression.ReturnType);
				if (type.Name == "function_name")
				{
					isFunctionCall = true;

					if (!_nextFunctionIsScript)
					{
						FunctionInfo info = _opcodes.GetFunctionInfo(expression.Opcode);
						if (info != null)
						{
							if (info.Name.StartsWith("begin"))
							{
								firstIndentedArg = 0;
								if (expression.LineNumber > 0 && !_onNewLine)
								{
									output.Indent++;
									output.WriteLine();
								}
							}
							else if (info.Name == "if")
							{
								firstIndentedArg = 1;
							}

						}
					}
					if (expression.LineNumber > 0)
						output.Write("(");
				}
			}

			bool wroteAnything = HandleExpression(expression, output);
			int startIndent = output.Indent;

			int currentArg = 0;

			if (_h4 && firstrun)
			{
				firstIndentedArg = 0;
				currentArg = 1;
				_h4 = false;
			}

			ScriptExpression sibling = expression.NextExpression;
			while (sibling != null)
			{
				if (wroteAnything && !_nextExpressionIsVar)
				{
					if (currentArg == firstIndentedArg)
						output.Indent++;
					if (currentArg >= firstIndentedArg)
					{
						output.WriteLine();
						_onNewLine = true;
					}
					else if (output.Indent != startIndent)
					{
						output.WriteLine();
						_onNewLine = true;
					}
					else
					{
						output.Write(" ");
					}
				}

				if (!_nextExpressionIsVar)
					wroteAnything = HandleExpression(sibling, output);
				else if ((_nextExpressionIsVar && sibling.Opcode != 0xFFFF))
				{
					if (!_varTypeWritten)
					{
						ScriptValueType type = _opcodes.GetTypeInfo((ushort)sibling.ReturnType);
						output.Write(type.Name + " var_" + localVarCounter.ToString() + " ");
						_varTypeWritten = true;
					}
					
					wroteAnything = HandleExpression(sibling, output);
				}

				sibling = sibling.NextExpression;
				currentArg++;
			}

			if (isFunctionCall && expression.LineNumber > 0)
			{
				if (output.Indent != startIndent)
				{
					output.Indent = startIndent;
					if (wroteAnything)
						output.WriteLine();
					output.Write(")");
					_onNewLine = true;
				}
				else
				{
					output.Write(")");
				}
			}


		}

		private bool HandleExpression(ScriptExpression expression, IndentedTextWriter output)
		{
			short realtype = (short)expression.Type;
			short clippedtype = (short)((short)expression.Type & 0xFF);

			switch ((ScriptExpressionType) clippedtype)
			{
				case ScriptExpressionType.Expression:
				case ScriptExpressionType.Expression4:
					return GenerateExpressionCode(expression, output);

				case ScriptExpressionType.GlobalsReference:
				case ScriptExpressionType.GlobalsReference4:
					{
						if ((realtype & 0xFF00) > 0)
							return GenerateVariableReference(expression, output, true);
						else
						return GenerateGlobalsReference(expression, output);
					}
					

				case ScriptExpressionType.ParameterReference:
				case ScriptExpressionType.ParameterReference4:
					return GenerateParameterReference(expression, output);

				case ScriptExpressionType.ScriptReference:
				case ScriptExpressionType.ScriptReference4:
					return GenerateScriptReference(expression, output);

				case ScriptExpressionType.Group:
				case ScriptExpressionType.Group4:
					return GenerateGroup(expression, output);

				case ScriptExpressionType.VariableReference4:
					return GenerateVariableReference(expression, output);

				case ScriptExpressionType.VariableDecl4:
					return GenerateVariableDecl(expression, output);

				default:
					throw new InvalidOperationException("Unknown script expression type");
			}
		}

		private bool GenerateExpressionCode(ScriptExpression expression, IndentedTextWriter output)
		{
			if (expression.LineNumber == 0)
				return false;

			_onNewLine = false;
			ScriptValueType type = _opcodes.GetTypeInfo((ushort) expression.ReturnType);
			ScriptValueType actualType = type;
			if (type.Name != "function_name")
			{
				// Check if a typecast is occurring

				if (expression.Opcode != 0xFFFF)
				{
					actualType = _opcodes.GetTypeInfo(expression.Opcode);

					if (actualType.Quoted)
					{
						if (expression.Value.UintValue != 0xFFFFFFFF)
							output.Write("\"{0}\"", expression.StringValue);
						else
							output.Write("none");
						return true;
					}
				}
			}

			uint value = GetValue(expression, type, _endian);

			byte[] val = BitConverter.GetBytes(value);

			switch (type.Name)
			{
				case "void":
					return false;
				case "boolean":
					if (BitConverter.ToBoolean(val,0))
						output.Write("true");
					else
						output.Write("false");
					break;
				case "short":
					output.Write(BitConverter.ToInt16(val,0));
					break;
				case "long":
					// Signed integer
					output.Write((int) value);
					break;
				case "real":
					// Eww
					//var floatBytes = new byte[4];
					//floatBytes[0] = (byte) (value & 0xFF);
					//floatBytes[1] = (byte) ((value >> 8) & 0xFF);
					//floatBytes[2] = (byte) ((value >> 16) & 0xFF);
					//floatBytes[3] = (byte) ((value >> 24) & 0xFF);
					var fl = BitConverter.ToSingle(val, 0);
					output.Write(fl.ToString("0.0#######", CultureInfo.InvariantCulture));
					break;
				case "function_name":
					if (_nextFunctionIsScript)
					{
						if (expression.Opcode >= _scripts.Scripts.Count)
							output.Write("import#" + expression.StringValue);
						else
							output.Write(expression.StringValue); // todo: there are cases (h3 xbox mainmenu's campaign_cam specifically) where the function_name expression's opcode value is +1 from what it should be, and the expression prior has the right index.
							// the current state of this script code doesnt seem to be good enough to step back so here is the hacky fix implemented in the HO fork.

							//output.Write(_scripts.Scripts[expression.Opcode].Name);

						_nextFunctionIsScript = false;
					}
					else
					{
						FunctionInfo info = _opcodes.GetFunctionInfo(expression.Opcode);
						if (info == null)
							output.Write("UNNAMED_OPCODE_" + expression.Opcode.ToString("X4") + "#" + expression.StringValue);
						else
							output.Write(info.Name);
						//throw new InvalidOperationException("Unrecognized function opcode 0x" + expression.Opcode.ToString("X"));
					}
					break;
				case "unit_seat_mapping":
					// This isn't the technical way of doing this,
					// but since seat mapping names aren't stored anywhere,
					// it would be tricky to resolve them unless we just use an index for now
					if (expression.Value.UintValue != 0xFFFFFFFF)
						output.Write(expression.StringValue);
					else
						output.Write("none");
					break;
				case "unparsed":
					break;
				default:
					string enumValue = actualType.GetEnumValue(value);
					if (enumValue != null)
					{
						output.Write(enumValue);
					}
					else if (expression.Value.IsNull)
					{
						output.Write("none");
					}
					else
					{
						enumValue = expression.StringValue;
						if (enumValue != null)
							output.Write(enumValue);
						else
							output.Write("0x{0:X}", value);
					}
					break;
			}
			return true;
		}

		private bool GenerateGlobalsReference(ScriptExpression expression, IndentedTextWriter output)
		{
			_onNewLine = false;
			output.Write(expression.StringValue);
			return true;
		}

		private bool GenerateParameterReference(ScriptExpression expression, IndentedTextWriter output)
		{
			_onNewLine = false;
			output.Write(expression.StringValue);
			return true;
		}

		private bool GenerateVariableReference(ScriptExpression expression, IndentedTextWriter output, bool islocal = false)
		{
			_onNewLine = false;
			string varDesc = islocal ? ("var_" + expression.Value.ToString() + "#") : "";
			output.Write(varDesc + expression.StringValue);
			return true;
		}

		private bool GenerateVariableDecl(ScriptExpression expression, IndentedTextWriter output)
		{
			_onNewLine = false;
			output.Write("(local ");
			var expressionIndex = new DatumIndex(expression.Value.UintValue);
			_nextExpressionIsVar = true;
			_varTypeWritten = false;
			GenerateCode(_scripts.Expressions.FindExpression(expressionIndex), output);
			_nextExpressionIsVar = false;
			localVarCounter++;
			output.Write(")");
			return true;
		}

		private bool GenerateScriptReference(ScriptExpression expression, IndentedTextWriter output)
		{
			var expressionIndex = new DatumIndex(expression.Value.UintValue);

			_nextFunctionIsScript = true;
			GenerateCode(_scripts.Expressions.FindExpression(expressionIndex), output);
			_nextFunctionIsScript = false;
			return true;
		}

		private bool GenerateGroup(ScriptExpression expression, IndentedTextWriter output)
		{
			var childIndex = new DatumIndex(expression.Value.UintValue);
			if (!childIndex.IsValid)
				throw new InvalidOperationException("Group expression has no child");

			GenerateCode(_scripts.Expressions.FindExpression(childIndex), output);
			return true;
		}

		private uint GetValue(ScriptExpression expression, ScriptValueType type, Endian endian)
		{
			if (endian == Endian.BigEndian)
				return expression.Value.UintValue >> (32 - (type.Size * 8));
			else
				return expression.Value.UintValue;
		}
	}
}

#endif
